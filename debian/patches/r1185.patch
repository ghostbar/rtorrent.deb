Description: Fix for segfaults with xmlrpc. Closes: #605863, #606796.
Origin: Upstream SVN revisions r1185, r1186, r1188 collapsed.
Bug-Debian: http://bugs.debian.org/605863
Bug-Debian: http://bugs.debian.org/606796
Last-Update: 2011-03-09
--- a/src/signal_handler.h
+++ b/src/signal_handler.h
@@ -44,8 +44,13 @@
 public:
   typedef sigc::slot0<void> Slot;
 
+#ifdef NSIG
+  static const unsigned int HIGHEST_SIGNAL = NSIG;
+#else
+  // Let's be on the safe side.
   static const unsigned int HIGHEST_SIGNAL = 32;
-  
+#endif
+
   static void         set_default(unsigned int signum);
   static void         set_ignore(unsigned int signum);
   static void         set_handler(unsigned int signum, Slot slot);
--- a/src/thread_base.cc
+++ b/src/thread_base.cc
@@ -112,6 +112,7 @@
   // Init the poll manager in a special init function called by the
   // thread itself. Need to be careful with what external stuff
   // create_poll_manager calls in that case.
+  std::memset(&m_thread, 0, sizeof(pthread_t));
 
   m_taskShutdown.set_slot(rak::ptr_fn(&throw_shutdown_exception));
 
--- a/src/thread_main.cc
+++ b/src/thread_main.cc
@@ -53,4 +53,5 @@
   m_pollManager->get_torrent_poll()->set_flags(torrent::Poll::flag_waive_global_lock);
 
   m_state = STATE_INITIALIZED;
+  m_thread = pthread_self();
 }
--- a/src/signal_handler.cc
+++ b/src/signal_handler.cc
@@ -43,8 +43,8 @@
 
 void
 SignalHandler::set_default(unsigned int signum) {
-  if (signum >= HIGHEST_SIGNAL)
-    throw std::logic_error("SignalHandler::clear(...) received invalid signal value");
+  if (signum > HIGHEST_SIGNAL)
+    throw std::logic_error("SignalHandler::set_default(...) received invalid signal value.");
 
   signal(signum, SIG_DFL);
   m_handlers[signum].disconnect();
@@ -52,8 +52,8 @@
 
 void
 SignalHandler::set_ignore(unsigned int signum) {
-  if (signum >= HIGHEST_SIGNAL)
-    throw std::logic_error("SignalHandler::clear(...) received invalid signal value");
+  if (signum > HIGHEST_SIGNAL)
+    throw std::logic_error("SignalHandler::set_ignore(...) received invalid signal value.");
 
   signal(signum, SIG_IGN);
   m_handlers[signum].disconnect();
@@ -61,11 +61,11 @@
 
 void
 SignalHandler::set_handler(unsigned int signum, Slot slot) {
-  if (signum >= HIGHEST_SIGNAL)
-    throw std::logic_error("SignalHandler::handle(...) received invalid signal value");
+  if (signum > HIGHEST_SIGNAL)
+    throw std::logic_error("SignalHandler::set_handler(...) received invalid signal value.");
 
   if (slot.empty())
-    throw std::logic_error("SignalHandler::handle(...) received an empty slot");
+    throw std::logic_error("SignalHandler::set_handler(...) received an empty slot.");
 
   signal(signum, &SignalHandler::caught);
   m_handlers[signum] = slot;
@@ -73,11 +73,11 @@
 
 void
 SignalHandler::caught(int signum) {
-  if ((unsigned)signum >= HIGHEST_SIGNAL)
-    throw std::logic_error("SignalHandler::caught(...) received invalid signal from the kernel, bork bork bork");
+  if ((unsigned)signum > HIGHEST_SIGNAL)
+    throw std::logic_error("SignalHandler::caught(...) received invalid signal from the kernel, bork bork bork.");
 
   if (m_handlers[signum].empty())
-    throw std::logic_error("SignalHandler::caught(...) received a signal we don't have a handler for");
+    throw std::logic_error("SignalHandler::caught(...) received a signal we don't have a handler for.");
 
   m_handlers[signum]();
 }
